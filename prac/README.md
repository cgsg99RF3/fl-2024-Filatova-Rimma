Филатова Римма Б05-325

Запуск для прохождения тестов: mkdir build && cd build && cmake -DCMAKE_BUILD_TYPE=Debug .. && make coverage

Запуск для обычного режима: cd example && mkdir build && cmake .. && ./a.out

Вариант 8.

Решение задачи:  
Создадим стек в который будем класть данные об элементах при прочтении обратной польской нотации.
Эти данные - массивы dp, где dp[i] - минимальная длина слова, содержащего префикс из i символов x, удолетворяющего регулярному выражению, которое в данный момент кладем на стек.
Изначально для всех i dp[i] = INF

Читаем нотацию: если символ - элемент алфавита (буква a, b, c) - dp[0] = 1, если этот сивол совпадает с x - dp[1] = 1; При этом кладем данный массив на стек.
Если прочитали символ *, +, ., то снимаем со стека сооветствующее кол-во элементов, считаем dp для новой регулярки.

При *: снимаем elem1. Если в регулярки для elem1 есть слово, длины i, которое состоит только из символов x, то dp[i * k] = min(elem1[i] * k, dp[i]) 
При этом всегда dp[0] = 0;  
При +: снимаем 2 элемента elem1, elem2, dp[i] = min(elem1[i], elem2[i])  
При .: Снимаем 2 элемента elem1, elem2. Если для регулярки для elem1 есть слово длины i, которое состоит только из x, то в конец можно дописать elem2[j] и получить слово с префиксом из i + j символов x;
Поэтому если это верно: dp[j] = min(dp[j], elem1[t] + elem2[j - t]). Иначе - дописать нельзя dp[j] = elem1[j] 

После работы со специальным символом кладем полученное dp на стек.

Осталось уточнить детали:  
dp[0] = 1 для отдельный символов.

Если прочитанный из нотации символ не в алфавите и не специальный символ - это exception.

Если прочитали все символы, а в стеке не 1 элемент - изначально поступило не корректное регулярное выражение.

Если операнд требует 2 символа, а на стеке только 1 или 0 - изначально поступило не корректное регулярное выражение.